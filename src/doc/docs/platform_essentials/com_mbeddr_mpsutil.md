This documentation gives an introduction to the subproject *com.mbeddr.mpsutil* of {{ mbeddr() }}. 

!!! warning "Documentation in progress"
    Some of the older languages are already documented here
    but might need some fixes to work with the latest version of the platform. Other languages are not documented at all.


The project contains a bunch of different utility languages and solutions:

## AsyncCell

The async cell allows to display a text based loading indicator as long as the return string is null.

Create a new `$custom cell$` editor cell and return a new AsyncCellProvider:

```java
return new AsyncCellProvider(node, { =>
    string value = calculateValue(); // calculate or query your value here
    if (value.isEmpty) { return null; }
    Style style = editorContext.?getContextCell().?getStyle();
    return new AsyncCellValue(value, style);
});
```

![async cell](async_cell.gif)

## Dataflow

> ^^com.mbeddr.mpsutil.favourites^^

MPS-DF is a data-flow extension for MPS. Please visit the following page for more information:

[An Extensible Framework for Variable-precision Data-flow Analyses in MPS | TamÃ¡s SzabÃ³](https://szabta89.github.io/projects/df.html)

## Favourites plugin

> ^^com.mbeddr.mpsutil.favourites.plugin^^

The favourites view is implemented using the language ^^com.mbeddr.mpsutil.projectview^^ from [MPS-extensions](https://jetbrains.github.io/MPS-extensions/extensions/other/project-view/).

![project view: favourites](https://jetbrains.github.io/MPS-extensions/extensions/img/favourites.png)

There's an action `Add to Favourites` to add a node to this view. The node can be removed by executing the action
`Remove from Favourites`. Internally, the plugin is implemented using node annotations.

## Parameterized menu

> ^^com.mbeddr.mpsutil.parameterizedMenu^^

This language is an extension to the *parameterized* transformation language part. When used as a menu part of it, it allows
iterating over the parameter object (*parameterizable parameterized* menu part) or create a dynamic submenu based on
the parameter object (*parameterized submenu*).

## Build utilities

> ^^com.mbeddr.mpsutil.buildutil^^

!!! warning "This language was an attempt to automatically update build scripts during the build. It will be removed in the future."

## Code completion menu

> ^^com.mbeddr.mpsutil.ccmenu^^

!!! warning "This language isn't used anymore and disabled."

This language added support for customizing the code completion menu with tabs and a special tab for creating reference
targets. The contributions were made in a plugin solutions by creating a [CCMenuExtensions](http://127.0.0.1:63320/node?ref=r%3A3d5b7b5d-2674-4caf-bdca-c100c5a0cb8e%28com.mbeddr.mpsutil.ccmenu.structure%29%2F6243347984996272104) root node.

![example:ccmenu](ccmenu_example.png)

For completion styling and item priorities, use [completion styling](https://blog.jetbrains.com/mps/2019/04/jetbrains-mps-2019-1-custom-style-for-completion-menu-static-methods-in-baselanguage-custom-ui-themes-and-more/#Custom_style_and_priority_of_completion_items_Client_Sponsored) instead.

## Concept diagram

> ^^com.mbeddr.mpsutil.conceptdiagram^^

![example:conceptdiagram](conceptdiagram_example.png)

Create a new root node of type [ConceptDiagram](http://127.0.0.1:63320/node?ref=r%3A40ee9130-2844-4f59-96e6-d12b358ca46c%28com.mbeddr.mpsutil.conceptdiagram.structure%29%2F2634829965774842138). The editor should now contain an empty editor. Nodes can be dragged
from the *Diagram Palette* to the diagram. If nodes from other languages are needed, add the language to the *languages*
section.

TODO: explain how it works

## Context actions

> ^^com.mbeddr.mpsutil.contextactions^^

!!! warning "There is a Context Actions (JetBrains) and Context Actions 2 (mbeddr) tool. Please use the one from JetBrains instead of this language."

This language adds a tool with context-specific editor actions that can be navigated by mouse. For more information about the
JetBrains implementation, visit the page [Context acions tool | MPS](https://www.jetbrains.com/help/mps/context-actions-tool.html).

## Dependencies diagram

> ^^com.mbeddr.mpsutil.dependenciesdiagram^^

## ECore

> ^^com.mbeddr.mpsutil.ecore^^

This is an importer and exporter for the meta model([ECore](https://wiki.eclipse.org/Ecore)) of the Eclipse Modelling Framework.
The conversion is between an XML file and a MPS model. The improter can import Ecore and Ecore model files.

The actions can be accessed through right-clicking a model and opening the *Ecore Transformation tools* group.

## Generated artifacts review

> ^^com.mbeddr.mpsutil.genreview^^

This tool can be used to view artifacts that where generated by a generator. It has a special color mapping for Java files.
The button `Highlight lines not linked` should highlight the lines which are not related to any node. When there are multiple
original nodes that can be traced to a certain file and line, the previous and next button can be used to navigate to these
nodes (TODO: not working or can't find example).

![generated artifacts reviewer](generated_artifacts_reviewer.png)

## JSON

> ^^com.mbeddr.mpsutil.json^^

This language implements a simple JSON language that can be used as a generator target. The [Json file](http://127.0.0.1:63320/node?ref=r%3Abe665d13-1e1d-44cd-9817-8bd4d610f422%28com.mbeddr.mpsutil.json.structure%29%2F4342692121161094115) root node
supports an additional package name which is used as the folder inside the generation folder where the file is generated
into.

An example for a file that can be generated:

```json
{ 
  "description" : "This is a json file", 
  "name" : "my json file", 
  "this is an object" : { 
    "And another object" : { 
      "With a description" : "object description", 
      "An array" : [ 
        "valu1", 
        "value2" 
      ], 
      "withANumber" : 1.232E+231231, 
      "empty array" : [ ], 
      "empty object" : { }, 
      "empty string" : "" 
    } 
  } 
}
```

## JUNG framework

> ^^com.mbeddr.mpsutil.jung^^

As an additional means of displaying relationships between nodes (next to PlantUML and the tree views) we have integrated
the [JUNG](http://jung.sourceforge.net/) framework for graph display. As a language developer, you can implement an interface IJGraphProvider and implement a method that creates the graph:

- Programmable with high-level API
- Specify initial layout
- Configurable node size, color, line style and color, fill color, shape and label
- Configurable edge width, style, color and label
- Configurable tooltip text for nodes and edges
- Extensibility to plug in your own layouters (such as the one from yWorks)

Once you have created a graph, your users have many options to view the graph in an MPS tool window:

- Double-click selects node or edge in editor
- Zoom and Pan
- Tooltips
- Selectable Layouts
- Selection and highlighting of outgoing and incoming nodes and edges
- Filtering based on node and edge type
- Filtering along a continuous axis (for example, time)
- Incremental, node-based collapsing and expansion

![example: JUNG framework](jung2.png)

The JUNG integration is available as part of mbeddr, but also as part of the mbeddr.platform, so you can use it for your own languages. Check out the Chunk node for an example of how to use it.

A demo video of the viewer can be found [here](http://youtu.be/-v1X0GhsLJ4).

To use it in your own language, implement the [IJGraphProvider](http://127.0.0.1:63320/node?ref=d09a16fb-1d68-4a92-a5a4-20b4b2f86a62%2Fr%3A6e32694b-6dd1-4530-b48f-4e3bf97b2744%28com.mbeddr.mpsutil.jung%2Fcom.mbeddr.mpsutil.jung.structure%29%2F6388491840914066147) interface. Return a JNGraph from the getGraph() method. Check out the existing implementations, and in particular the DepGraphHelper (called from Chunk.getGraph()) to learn the details. In short, a graph is built in two steps: the first step actually adds the nodes and edges. The second step uses closures to style the graph. Examples can be seen from DepGraphHelper.

## Lantest

!!!error "This language isn't working anymore."

> ^^com.mbeddr.mpsutil.lantest^^

This language was an attempt to automatically test languages, for example, check if the generation of files finished successfully
or check that existing models can be instantiated again via the editor (for example: discover bugs in constraints).

## Multilingual

!!!warning "This language might be removed in the future."

> ^^com.mbeddr.mpsutil.multilingual^^

The idea behind this language was to store text translations in properties files and load the through the Java [ResourceBundle](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ResourceBundle.html) class. The documentation for the language
can be found [here as a PDF](../../files/multilingual.pdf) and is located in the virtual package ^^doc.com.mbeddr.mpsutil^^.

## Richstring

> ^^com.mbeddr.mpsutil.richstring^^

This BaseLanguage extension simplifies usage of variables and [Java String.format()](https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html) inside BaseLanguage Strings. Just add the language com.mbeddr.mpsutil.richstring to your model.

The following example shows referencing a simple variable, embedding an expression inside a string, and the equivalent of calling `#!java String.format()`:

![example: richstring](richstring_example.png)

## Typesystem trace

> ^^com.mbeddr.mpsutil.typesystem.trace^^

## MPS util library

> ^^com.mbeddr.mpsutil.test.util^^

## BLDoc

> ^^com.mbeddr.mpsutil.bldoc^^

## FrameCell

> ^^com.mbeddr.mpsutil.framecell^^

## Language stats

> ^^com.mbeddr.mpsutil.langstats^^

## Icon char

> ^^com.mbeddr.mpsutil.iconchar^^

## License manager

> ^^com.mbeddr.mpsutil.licensemanager.common^^

## Default values for properties

> ^^com.mbeddr.mpsutil.propertydefault^^

## Suppress warning

> ^^com.mbeddr.mpsutil.suppresswarning^^

## Test scope

> ^^com.mbeddr.mpsutil.testScope^^

## Var scope

> ^^com.mbeddr.mpsutil.varscope^^

## XML.fix

> ^^com.mbeddr.mpsutil.xml.fix^^

## Editor utils

> ^^com.mbeddr.mpsutil.editor.utils^^

## File picker

> ^^com.mbeddr.mpsutil.filepicker^^

## Actions filter

> ^^com.mbeddr.mpsutil.actionsfilter^^

## Comparator

> ^^com.mbeddr.mpsutil.comparator^^

## Date picker

> ^^com.mbeddr.mpsutil.datepicker^^

## Editing guide

> ^^com.mbeddr.mpsutil.editingGuide^^

## Extension class

> ^^com.mbeddr.mpsutil.extensionclass^^

## Graphstream

> ^^com.mbeddr.mpsutil.graphstream^^

## HTTP support

> ^^com.mbeddr.mpsutil.httpsupport^^

!!! warning "This was the old http support plugin. Please use the language jetbrains.mps.ide.httpsupport instead."

## Hyperlink

> ^^com.mbeddr.mpsutil.hyperlink^^

 Hyperlink cells can be used for references in MPS. In contrast to normal reference cells they automatically become blue and underlined if the mouse hovers over them (no Ctrl is necessary). The following style attributes are supported:

- **hyperlink-reference**: make a reference a hyperlink
- **hyperlink-handler**: a function that is called when the link is clicked. The *util* parameter object contains a method
*openInBrowser* for opening an URL with the default web browser.
- **hyperlink-style**: can be URl or reference. The reference style forces the use of ctrl to activate the hyperlink.
- **hyperlink-node**: the node that should be displayed after the link was clicked
- **hyperlink-focus**: focus the target node of the hyperlink after navigating to it.
- **hyperlink-select**: select the target node of the hyperlink after navigating to it.

## Incremental computation

> ^^com.mbeddr.mpsutil.incrementalcomputation^^

## Interpreter 

> ^^com.mbeddr.mpsutil.interpreter^^
 
The interpreter is described on the [interpreter](interpreter.md) page.

## JFreeChart

> ^^com.mbeddr.mpsutil.jfreechart^^

This module contains stubs for the [jfreechart](https://www.jfree.org/jfreechart/) library. The charts can be viewed in
an extra tool *Chart* by calling the following code: 

```java
ChartManager.getInstance(editorContext).setChart(node.createChart())
```

where `createChart` return instance of [JFreeChart](http://127.0.0.1:63320/node?ref=7fe13e34-8620-4d5d-92c7-df091b0ed628%2Fjava%3Aorg.jfree.chart%28com.mbeddr.mpsutil.jfreechart.runtime%2F%29%2F%7EJFreeChart).

## Margin cell / review

> ^^com.mbeddr.mpsutil.margincell^^ and ^^com.mbeddr.mpsutil.review^^

Margin cells are editor cells that are shown beyond the right editor margin, a little bit like comments in Word. In fact, the ReviewNote cell implements exactly Word's comment facility as an example of the margin cell. Here is a screenshot:

![example: margin cell](margincell_example.png)

To use the review notes, just include the respective language; intentions are available to attach review notes to editor cells.

To put your own cells into the right margin, your cell must implement the IMarginCellContent interface. The editor of your cell may use the *margincell-cell-width* and *margincell-dashed-line-interval* style attributes to design the width and line style. You also have to have the actual margincell on the root element of the editor. However, as illustrated by the CommentAnnotationContainer from the review language, you can use an annotation for this. Hence, margin comments can essentially be added to every model, without the model's language being aware of it.

## Placeholder text list

> ^^com.mbeddr.mpsutil.placeholderTextList^^

This language adds a new [cell model](http://127.0.0.1:63320/node?ref=r%3Ae633d72e-7309-4abb-b48b-c0511f07461b%28com.mbeddr.mpsutil.placeholderTextList.structure%29%2F1739942158294184652) that supports multiple aggregation with a custom placeholder text.

The placeholder can be specified in the inspector by creating a query function for the *placeholder text*.

## PlantUML

> ^^com.mbeddr.mpsutil.plantuml.node^^

This provides an integration of [PlantUML](https://plantuml.com/) with MPS. Watch [this old video](https://www.youtube.com/watch?v=QjwXITp6fwg) to get an overview.

To use it in your own languages, implement the [IVisualizable](http://127.0.0.1:63320/node?ref=b4d28e19-7d2d-47e9-943e-3a41f97a0e52%2Fr%3A4903509f-5416-46ff-9a8b-44b5a178b568%28com.mbeddr.mpsutil.plantuml.node%2Fcom.mbeddr.mpsutil.plantuml.node.structure%29%2F3225038607917463880) interface in your language concept. Each concept can have several visualizations, called categories. The `getCategories()` method returns the list (just strings). The `getVisualization()` method then returns the actual visualization. It gets the user-requested category as an argument, as well as an empty VisGraph object. The `getVisualization()` method then has to fill the VisGraph with the actual visualization. This is done simply by using the `add()` method to build a native, textual PlantUML visualization. Check out the existing implementations of the interface to learn the deails; in particular, there is a helper method on VisGraph that creates a URL for users to click on in the graph: `createUrl(node)`.

## postprocessGeneratedFiles

> ^^com.mbeddr.mpsutil.postprocessGeneratedFiles^^

Add a new node *generated files postprocessor facet* to the plugin aspect of a language to declare a new facet that
is executed after files are generated (textGen). It supports post processor functions that have a *node* parameter and 
a *path* parameter that contains the path of the generate file. This method can be, for example, used to copy the generated
files to a different folder:

```java
generated files postprocessor facet testGen
 
(node, path)->void {
    Path target = Paths.get("/var/tmp/testGen").resolve(path.getFileName());
    message info "Copying " + path + " to " + target, <no project>, <no throwable>;
    try {
    Files.createDirectories(target.getParent());
    Files.copy(path, target, StandardCopyOption.REPLACE_EXISTING);
    } catch (IOException e) {
    e.printStackTrace();
    }
}
```

For simple duplicating the TextGen outcome, there is also the builtin JetBrains annotation [CopyOutcome](http://127.0.0.1:63320/node?ref=r%3A4d7d5410-8d5a-45f2-a2f2-a6b7b42a377e%28jetbrains.mps.lang.makeup.structure%29%2F1223283106984741523).

## preferenceform

> ^^com.mbeddr.mpsutil.preferenceform^^

This language allows adding new preference pages to *Preferences*-->*Other Settings*. The language uses the IntelliJ platform
mechanishm for adding preference pages ([documentation](https://plugins.jetbrains.com/docs/intellij/settings-guide.html)).

Example:

![example: preference form](preferenceform_example.png)

It supports the following options:

- **scope**: save the preferences on application or project level
- **help topic**: TODO: where is the help topic shown

The preference form supports a few different input elements:

- password field
- checkbox
- dynamic combobox
- integer field
- predefined combobox
- text field

The *before write* method is called, when the button *Apply* or *OK* is pressed. This method should update all tools or classes
that reference the values of the preference form. The input fields can be accessed through the *this* object. Example:

```java
final HttpServerConfig config = new HttpServerConfig(((int) this.port), this.enabled); 
HttpServerConfig.setCurrentConfig(config); 
extensionPoint/HttpServerConfigChangeListener/.objects.forEach({~it => it.serverChanged(config); });
```

The *after read* method is called, after the state is loaded (e.g. when the preference form is opened).

## process

> ^^com.mbeddr.mpsutil.process^^

This language allows creating wizards with multiple steps:

![example: single step of a custom wizard](wizard_step_example.png)

Create a new node of instance [Process](http://127.0.0.1:63320/node?ref=r%3A2ffefd76-4fe0-43c2-9fbd-203c67a47b34%28com.mbeddr.mpsutil.process.structure%29%2F4724180912012603068). The wizard can have input parameters and produces one output. After defining
the wizard it can be invoked from an action. Example:

```
wizard<theProcess> wiz = createWizard<theProcess>("This is my testdata");
boolean b = wiz.show;
System.out.println("show == " + b);
wiz.finish;
```

The *show* method shows the modal dialog and checks if it was closed with the exit code *OK*. The *finish* method
 executed the *onFinish* callback of every step. For more information, have at look the [example](http://127.0.0.1:63320/node?ref=r%3A9aef0d3c-87c9-4ce3-ad67-def9817c1ab4%28com.mbeddr.mpsutil.process.sandbox.plugin%29%2F4724180912013515813).

## RCP

> ^^com.mbeddr.mpsutil.rcp^^

This language allows creating a new action for creating models similar to the action [New model](http://127.0.0.1:63320/node?ref=r%3A0a882e21-5553-485b-8777-3b0ace5a0d84%28com.mbeddr.core.base.pluginSolution.plugin%29%2F1268036453389576693) of mbeddr.
Create an instance of [NewModelDialogConfig](http://127.0.0.1:63320/node?ref=r%3A3f408a86-cd9f-4c3c-80d9-d614915b49c9%28com.mbeddr.mpsutil.rcp.structure%29%2F8503127430094868034). The following settings are supported:

- **name**: the name of the new action
- **caption**: the text that is shown for the action
- **user can change persistence**: boolean flag that decides if the user can change the model's persistence type.
- **default persistence**: the type of model persistence that is used when the model is created
- **optional devkits**: devkits that are automatically added when the model is created
- **show model properties**: open the model properties after the model was created

## Refactoring

> ^^com.mbeddr.mpsutil.refactoring^^

This language adds support for a projection mode switcher and refactoring actions.

### Projection mode switcher

The mbeddr platform has a group *Projection* which is a top-level menu in MPS:

![projection menu](projection_menu.png)

A projection mode switcher can be declared containing push hint options where the hints are referenced from an existing ConceptEditor context hints container. The action
can be added in the *Add to Menu/Button Group* section editor.

This adds a toggle to this menu/button group that toggles the referenced editor hint in the editors. When it should only
be enabled for a specific concept, add a concept to *only in editor with instance of*.

![example: projection mode switcher](projection_mode_switcher_example.png)

### Refactoring action

The concept [RefactoringAction](http://127.0.0.1:63320/node?ref=1fc20ffe-f35b-4791-a0b7-d706bad5c49a%2Fr%3A18d75373-a465-46d0-9749-aacc22a947bc%28com.mbeddr.mpsutil.refactoring%2Fcom.mbeddr.mpsutil.refactoring.structure%29%2F7518061998923573137) can create an action for a [simple refactoring](https://www.jetbrains.com/help/mps/mps-refactoring.html). The title of the action can be specified with *caption* and the keyboard shortcut can
be defined in *shortcut*. Refactoring parameters can be specified in *parameters*. There are a few different choosers which will be shown in
the refactoring dialog for the value of the parameters:

- *string*: chooser for selecting a text
- +node*: chooser for selecting a node using a filter. The filter is a function which has a list of nodes to refactor as a parameter and
should return a new filtered sequence of nodes.
- *project tree node*: chooser for selecting a node from the project tree

## SModule

> ^^com.mbeddr.mpsutil.smodule^^

This language adds new operations to modules:

- **add dependencies**: adds dependencies to one or more models to the module
- **add DevKits**: adds devkits to the modules
- **add languages to the module**: adds used languages to the module
- **add model**: adds a new model with the specified name to the module. The repository has to be specified as the second
parameter. If you press enter after the name, you can also add devkits, references to models and languages to the newly created
model. In the inspector, the storage type has to be declared: it can be per root or single file persistence.
- **add solution**: adds a new solution to the module. The virtual package can be specified (subfolder).

## SPreferences

> ^^com.mbeddr.mpsutil.spreferences^^



## Trace explorer

> ^^com.mbeddr.mpsutil.traceExplorer^^

This language contributes a new tool *Trace Explorer* than can show and navigate traces of a model e.g. from the interpreter.

An example can be seen in the [KernelF paper](https://voelter.de/data/pub/kernelf-reference.pdf#page=14).

## Unique names

> ^^com.mbeddr.mpsutil.uniquenames^^

MPS references all nodes by their id, not their name. Still, as humans, we see only the name, and this might be ambiguous. The Unique Names hint can be activated in MPS Preferences, Editor Hints. It shows as much of the full qualified name as required to render a name unique.

Example concept:

![example: unique names in concept declaration](uniquenames_concept_plain.png)

Example Base Language:

![example: unique names in Base Language](uniquenames_class_unique.png)

## User styles

> ^^com.mbeddr.mpsutil.userstyles^^

This language provides a new annotation *@userConfigurable*, that can be added to a style class in a style sheet 
(intention:*Make User Configurable*). After defining a name, the user can change the style in the preferences
(*Preferences*-->*Editor*-->*Color Scheme*-->*Code*). The following style class items are supported:

- **Foreground**: equivalent to *text-foreground-color*
- **Background**: equivalent to *text-background-color*
- **Bold**: equivalent to *font-style: bold*
- **Italic**: equivalent to *font-style: italic
- **Effects: Dotted lines, bold underscored, underscored, underwaved**: equivalent to *underlined*
- **Effects: strikeout**: equivalent to *strike-out*

Further useful links for developers:

- [Export IntelliJ editor themes as plugin | JetBrains blog](https://blog.jetbrains.com/platform/2017/12/export-intellij-editor-themes-as-plugins/)
- [UI Themes - Editor Schemes and Background Images | IntelliJ Platform Plugin SDK](https://plugins.jetbrains.com/docs/intellij/themes-extras.html)

## MPSutil common

> ^^com.mbeddr.mpsutil.mpsutil.common^^

TODO: existing page?

## Generator facade

> ^^com.mbeddr.mpsutil.generatorfacade^^

This language contains a class [GeneratorFacade](http://127.0.0.1:63320/node?ref=r%3A00bd75cf-1225-4ef5-9a7e-390aed8718dd%28com.mbeddr.mpsutil.generatorfacade.runtime%29%2F5915735921188775088) that helps with running the generator. In contains a method
`runGenerator` with different signatures that can run the generator with a specific generation plan for a defined model
with a custom handler for generator messages and custom generation parameters such as *save transient models* (default: *false*) or 
*generate in parallel* (default: yes, 4 threads).

## Generic actions

> ^^com.mbeddr.mpsutil.genericactions^^

As the name already implies, this language adds some new generic actions:

- **Decrease MPS Editor Font Size**: decreases the font size in the editor settings and updates all editors (ctrl + -)
- **Increase MPS Editor Font Size**: increases the font size in the editor settings and updates all editors (ctrl + +)
- **Reset MPS Editor Font Size**:: reset the font size to the default size (ctrl + 0, 13 pixels)
- **File Manager in Output Folder**: a new action in the context menu of models that opens the path of the generated files.
 This action won't work if the model doesn't generate output files.
- **File Manager in Module Folder**: a new action in the context menu of modules that opens the path of th module.

## Node access

> ^^com.mbeddr.mpsutil.nodeaccess^^

TODO: remove copy node url to clipboard (superceded by "Copy node reference as URL")

This language adds a new group of actions called *Copy/Paste Special* to the editor popup that opens when right-clicking
in the editor:

- **Copy Node as XML**: serialize the selected node to XML and copy it to the system clipboard.
- **Paste XML Node**: deserialize a previously copied node and insert it next to the currently selected node.
- **Copy Node Info to Clipboard**: copies some information (project, module, model, node, url) about a node to the system
 clipboard.

## Node difference

> ^^com.mbeddr.mpsutil.nodediff^^

TODO: remove language. Superceded by compared two nodes (JetBrains action)

## Print

> ^^com.mbeddr.mpsutil.print.pluginSolution^^

This language adds a new action to the general MPS *File* menu. The action *Print Editor* can be used to print the current
editor with a printer. If the operating system permits it, this action can also be used to create a PDF from the editor.

## RCP configuration

> ^^com.mbeddr.mpsutil.rcpconfig^^

## XModel actions

> ^^com.mbeddr.mpsutil.xmodel.actions^^

This language adds actions for automatically deriving [generation plans](https://www.jetbrains.com/help/mps/generation-plan.html).
For a single or list of modules there is the action `Generation Plan for Languages` which can be found in the context menu that
opens when you right-click the modules in the logical view. There is also an action *Derive Generation Plan* which derives
a generation plan for a model that has to be selected in a dialog that opens when executiing this action. It can be found
in the same places as the text preview action (for example, in the context menu of models).

## GenUtil

> ^^com.mbeddr.mpsutil.genutil^^

This language helps with managing user objects and creating temporary nodes for them:

```
createTempNode{hello -> "world"};
```

This expression creates a new node and assigns Base Language expressions to keys of it. The keys are set internally with
the *setref* statement which takes a key, a context node (here: the newly created node) and a target expression, and creates
a new user object for this node. For normal values, there are the *setref* and *getref* statements to set and retrieve
values from the user object respectively. For int values there are the statements *setint* and *getint*.

## Resources

> ^^com.mbeddr.mpsutil.resources^^

## Run configuration

> ^^com.mbeddr.mpsutil.runconfiguration^^

## Stubs

### Mockito

### Open CSV

### Batik

### org.xml

## Target chooser

> ^^com.mbeddr.mpsutil.targetchooser^^

The target chooser language provides a modal dialog for choosing nodes based on a predefined scope:

![example: target chooser](targetchooser_example.png)

Example code:

```java
TargetChooserOptions options = new TargetChooserOptions(); 
project.getModelAccess().runReadAction({ => 
  options.setScope(new arraylist<node<>>{node/TargetChooser/, node/TargetChooserDialog/, node/DefaultModuleScope/}); 
}); 
TargetChooser chooser = new TargetChooser(ProjectHelper.toIdeaProject(project), options);
TargetChooserDialog.chooseTarget(#project, options)
```

The *options* object has the following setters:

- **setInitial**: set the initial selected item. This can be a node or a model.
- **setSelectionValidator**: the selection validator checks if the selected target is valid or shows an error message when
there it is invalid. By default, no validation takes places (an empty validator is used).
- **setSNodeFilter**: this filter decides which nodes should be visible in the dialog (within the selected scope).
To show a node, you also have to return true for the root node, but not for all ancestors.
- **setModuleScope**: this scope defines the available modules that will be the sources for the nodes that will be displayed.
- **addModuleFilter**: an additional boolean filter for the modules of the module scope.
- **showModulesPool**: a flag that decides if the modules pool (last entry in logical view) should also be displayed in the dialog.
- **setModelFilter**: only keep the models of the specified scope where the filter returns true
- **setScope**: sets the scope for the items that should be displayed in the dialog. This can be in instance of 
[TargetChooserScope](http://127.0.0.1:63320/node?ref=r%3A24b43531-125c-4436-b4b0-f3444d2173fd%28com.mbeddr.mpsutil.targetchooser%29%2F7547442689028637169) or a sequence of nodes (+ ancestor filter). By default, the specified modules scope
with the specified model and node filers applied is used.

## Wait for

> ^^com.mbeddr.mpsutil.blutil.test.waitfor^^

This language contains a assert item *wait for* for tests, the waits for an expression to become true. If the condition
evaluates to false, the check is repeated every *m* millisecond until the timeout of *n* milliseconds is reached. Both
*m* and *n* can be set in the inspector of the statement. 

A usecase for this statement could be multi threaded code, where you have to wait for the result of a different thread:

```
boolean enoughTimeHasElapsed; 
ApplicationManager.getApplication().executeOnPooledThread({ => 
  try { 
    Thread.sleep(50); 
  } catch (InterruptedException e) { 
    e.printStackTrace(); 
  } 
  enoughTimeHasElapsed = true; 
}); 
wait for enoughTimeHasElapsed;
```

## Build assistant

> ^^com.mbeddr.mpsutil.buildassistant^^

## Make

> ^^com.mbeddr.mpsutil.make^^

## Tool runner

> ^^com.mbeddr.mpsutil.toolruner.plugin^^

## XML import

> ^^com.mbeddr.mpsutil.xmlImport.plugin^^

This plugin adds two actions for importing XML files into MPS:

- *Paste as XML Content*: this action is located in the editor context menu and parses XML code
and adds it to the next xml node or root node.
- *Import XML File(s)*: this actions parses on or multiple xml files and creates xml root nodes for them in the current
selected model.

## Forms

> ^^com.mbeddr.mpsutil.forms^^

## Lang plugin extension

> ^^com.mbeddr.mpsutil.lang.plugin.extensions^^

## Mapping labels

> ^^com.mbeddr.mpsutil.mappingLabels^^

## Gradle support

> ^^com.mbeddr.mpsutil.gradlesupport^^

This language was an attempt to create Gradle files from MPS. It has a concepts for
text files, single lines and multi lines. If you want to generate text files, use one of the 
[text generator plugins](https://jetbrains.github.io/MPS-extensions/extensions/generator/plaintext-gen/) from {{ mps_extensions() }}.