---
tags:
- reference
---

## Tools

### Context actions

> ^^com.mbeddr.mpsutil.contextactions^^

!!! warning "There's a Context Actions (JetBrains) and Context Actions 2 (mbeddr) tool. Please use the one from JetBrains instead of this language."

This language adds a tool with context-specific editor actions that can be navigated by mouse. For more information about the
JetBrains implementation, visit the page [Context actions tool | MPS](https://www.jetbrains.com/help/mps/context-actions-tool.html)

### Editing guide

> ^^com.mbeddr.mpsutil.editingGuide^^

This language allows creating interactive exercises for the end users that can be checked on the fly. An exercise contains several tasks and contain a reference to a following exercise. A single task contains a name, a description as well as the code block that should be
shown in the exercise. The monitor function checks the completion status of the task. The variable `program` refers to the code section, the `editorContext` can be used, for example,
to get the selected cell by calling `editorContext.getSelectedCell()`. The following objects can be returned:

- **MonitorResultDone**: the task was completed successfully, and the explanation is shown.
- **MonitorResultError**: the task was completed with an error.
- **MonitorResultHint**: the task was not completed successfully, and a hint is shown.

![editing guide: declaration of an exercise](editingguide_definition.png)

The task can't be started by clicking the play button next to the name of a task. A new
temporary model is created which contains the editable task.

![editing guide: exercise](editingguide_exercise.png)


### Favourites plugin

> ^^com.mbeddr.mpsutil.favourites.plugin^^

The favourites view is implemented using the language ^^com.mbeddr.mpsutil.projectview^^ from [MPS-extensions](https://jetbrains.github.io/MPS-extensions/extensions/other/project-view/).

![project view: favourites](https://jetbrains.github.io/MPS-extensions/extensions/img/favourites.png)

There's an action `Add to Favourites` to add a node to this view. The node can be removed by executing the action
`Remove from Favourites`. Internally, the plugin is implemented using node annotations.

### Generated artifacts review

> ^^com.mbeddr.mpsutil.genreview^^

!!! warning "This language might not work correctly anymore."

This tool can be used to view artifacts that where generated by a generator. It has a special color mapping for Java files.
The button `Highlight lines not linked` should highlight the lines which aren't related to any node. When multiple
original nodes can be traced to a certain file and line, the previous and next button can be used to navigate to these nodes.

![generated artifacts reviewer](generated_artifacts_reviewer.png)

### Graphstream

> ^^com.mbeddr.mpsutil.graphstream^^

This language adds support for [GraphStream](https://graphstream-project.org/), a dynamic Java graph library. It can show a graph inside a tool called *Graphing*. Have a look at the language
^^com.mbeddr.mpsutil.graphstream.example^^ to see how a graph can be loaded. A concept has to
implement the interface [GraphingElement](http://127.0.0.1:63320/node?ref=r%3Ae5f563f0-3312-4f0d-a6fe-8d43c8a221d4%28com.mbeddr.mpsutil.graphstream.structure%29%2F5447190170711933193). When the current selected node implements the interface,
a new menu *View Graph* appears in the editor context menu.

The tool itself has support for history, zooming, fitting the view and rendering the graph as
a [GraphViz](https://graphviz.org/) SVG.

![example: graphstream](graphstream_example.png)

### JUNG framework

> ^^com.mbeddr.mpsutil.jung^^

As an additional means of displaying relationships between nodes (next to PlantUML and the tree views)
the [JUNG](http://jung.sourceforge.net/) framework was integrated displaying graph.
As a language developer, you can implement an interface IJGraphProvider and implement a method that creates the graph:

- programmable with high-level API
- specify initial layout
- configurable node size, color, line style and color, fill color, shape and label
- configurable edge width, style, color and label
- configurable tooltip text for nodes and edges
- extensibility to plug in your own layouters (such as the one from yWorks)

Once you have created a graph, your users have many options for viewing the graph in an MPS tool window:

- double-click selects node or edge in editor
- zoom and pan
- tooltips
- selectable layouts
- selection and highlighting of outgoing and incoming nodes and edges
- filtering based on node and edge type
- filtering along a continuous axis (for example, time)
- incremental, node-based collapsing and expansion

![example: JUNG framework](jung2.png)

The JUNG integration is available as part of mbeddr, but also as part of the mbeddr\.platform, so you can use it for your own languages. Check out the Chunk node for an example of how to use it.

A demo video of the viewer can be found [here](http://youtu.be/-v1X0GhsLJ4).

To use it in your own language, implement the [IJGraphProvider](http://127.0.0.1:63320/node?ref=d09a16fb-1d68-4a92-a5a4-20b4b2f86a62%2Fr%3A6e32694b-6dd1-4530-b48f-4e3bf97b2744%28com.mbeddr.mpsutil.jung%2Fcom.mbeddr.mpsutil.jung.structure%29%2F6388491840914066147) interface. Return a JNGraph from the getGraph() method. Check out the existing implementations, and in particular the DepGraphHelper (called from Chunk.getGraph()) to learn the details. In short, a graph is built in two steps: the first step actually adds the nodes and edges. The second step uses closures to style the graph. Examples can be seen from DepGraphHelper.

### PlantUML

> ^^com.mbeddr.mpsutil.plantuml.node^^

This provides an integration of [PlantUML](https://plantuml.com/) with MPS. Watch [this old video](https://www.youtube.com/watch?v=QjwXITp6fwg) to get an overview.

To use it in your own languages, implement the [IVisualizable](http://127.0.0.1:63320/node?ref=b4d28e19-7d2d-47e9-943e-3a41f97a0e52%2Fr%3A4903509f-5416-46ff-9a8b-44b5a178b568%28com.mbeddr.mpsutil.plantuml.node%2Fcom.mbeddr.mpsutil.plantuml.node.structure%29%2F3225038607917463880) interface in your language concept. Each concept can have several visualizations, called categories. The `getCategories()` method returns the list (just strings). The `getVisualization()` method then returns the actual visualization. It gets the user-requested category as an argument, as well as an empty VisGraph object. The `getVisualization()` method then has to fill the VisGraph with the actual visualization. This is done simply by using the `add()` method to build a native, textual PlantUML visualization. Check out the existing implementations of the interface to learn the details; in particular, There's a helper method on VisGraph that creates a URL for users to click in the graph: `createUrl(node)`.


### Tool runner

> ^^com.mbeddr.mpsutil.toolrunner.plugin^^

This solution provides an extension point ToolsSanityCheckerProvider that allows registering instances of [ToolsAvailabilityChecker](http://127.0.0.1:63320/node?ref=r%3Aeb55a79e-712e-453c-8ff8-d50d0340bc94%28com.mbeddr.mpsutil.toolrunner%29%2F8869103559931921994)
This interface checks the availability of external tools and their proper configuration and can be called through `ToolsInstallationSanityChecker.check`. There's also a class [ToolRunnerBase](http://127.0.0.1:63320/node?ref=r%3Aeb55a79e-712e-453c-8ff8-d50d0340bc94%28com.mbeddr.mpsutil.toolrunner%29%2F4775168500935975079), a base class for running external tools. It supports running the tool with a progress indicator, a customizable timeout and reading the (error) output.

### Trace explorer

> ^^com.mbeddr.mpsutil.traceExplorer^^

This language contributes a new tool *Trace Explorer* than can show and navigate traces of a model e.g. from the interpreter.

An example can be seen in the [KernelF paper](https://voelter.de/data/pub/kernelf-reference.pdf#page=14). The IETS3 tracing is explained on the [interpreter page](interpreter.md#tracing-in-kernelf).